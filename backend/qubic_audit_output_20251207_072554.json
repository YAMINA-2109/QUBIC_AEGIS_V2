{
  "functional_spec": "**Functional Specification Introduction**\n\n### Objective\nThe objective of this smart contract, named HM25Plus, is to provide a set of procedures and functions that manage invocation rewards and track the number of calls for each procedure. The contract aims to demonstrate a basic implementation of a Qubic C++ smart contract, showcasing the use of procedures, functions, and state management.\n\n### Context\nThis smart contract is designed to operate within the Qubic ecosystem, utilizing the QPI namespace and adhering to the Qubic C++ smart contract development guidelines. The contract is intended for use in a decentralized environment, where it will be deployed and executed on a Qubic-compatible blockchain.\n\n### Core Principles\nThe HM25Plus smart contract is built upon the following core principles:\n\n* **Modularity**: The contract is designed to be modular, with separate procedures and functions for each specific task, making it easier to maintain and update.\n* **Reusability**: The contract's procedures and functions are designed to be reusable, reducing code duplication and improving overall efficiency.\n* **Readability**: The contract's code is written with readability in mind, using clear and concise naming conventions, comments, and formatting to facilitate understanding and maintenance.\n\n### Input Format\nThe HM25Plus smart contract accepts the following input formats:\n\n| Procedure/Function | Input Struct | Description |\n| --- | --- | --- |\n| Echo | `Echo_input` | Empty input struct, no parameters required |\n| Burn | `Burn_input` | Empty input struct, no parameters required |\n| Bonus | `Bonus_input` | Empty input struct, no parameters required |\n| GetAllStats | `GetAllStats_input` | Empty input struct, no parameters required |\n\nNote: The input structs are currently empty, as the procedures and functions do not require any input parameters. However, this may change in future iterations of the contract.",
  "flow_diagram": "graph TD\n    Start[Start] --> Initialize[Initialize Contract State]\n    Initialize --> ProcedureSelection[Select Procedure]\n    ProcedureSelection -- Echo --> EchoProcedure[Execute Echo Procedure]\n    ProcedureSelection -- Burn --> BurnProcedure[Execute Burn Procedure]\n    ProcedureSelection -- Bonus --> BonusProcedure[Execute Bonus Procedure]\n    ProcedureSelection -- GetAllStats --> GetAllStatsFunction[Execute GetAllStats Function]\n    EchoProcedure --> IncrementEchoCount[Increment Echo Call Count]\n    IncrementEchoCount --> CheckInvocationReward[Check Invocation Reward]\n    CheckInvocationReward -- Yes --> TransferReward[Transfer Invocation Reward to Invocator]\n    CheckInvocationReward -- No --> EndEcho[End Echo Procedure]\n    BurnProcedure --> IncrementBurnCount[Increment Burn Call Count]\n    IncrementBurnCount --> CheckInvocationRewardBurn[Check Invocation Reward]\n    CheckInvocationRewardBurn -- Yes --> BurnInvocationReward[Burn Invocation Reward]\n    CheckInvocationRewardBurn -- No --> EndBurn[End Burn Procedure]\n    BonusProcedure --> IncrementBonusCount[Increment Bonus Call Count]\n    IncrementBonusCount --> GetInvocationReward[Get Invocation Reward]\n    GetInvocationReward --> CheckReward[Check Reward]\n    CheckReward -- GreaterThan1 --> TransferHalfReward[Transfer Half of Reward to Invocator]\n    TransferHalfReward --> BurnHalfReward[Burn Half of Reward]\n    CheckReward -- LessThanOrEqualTo1 --> BurnReward[Burn Reward]\n    GetAllStatsFunction --> CreateOutput[Create Output Object]\n    CreateOutput --> SetOutputFields[Set Output Fields to Call Counters]\n    SetOutputFields --> ReturnOutput[Return Output Object]\n    EndEcho --> End[End]\n    EndBurn --> End\n    End[End]",
  "detailed_documentation": "**Technical Section: HM25Plus Smart Contract**\n\n### Objective\n\nThe HM25Plus smart contract is designed to manage and track the invocation rewards of various procedures and functions. The contract features four main functions: Echo, Burn, Bonus, and GetAllStats. The Echo procedure returns the full invocation reward to the invocator, the Burn procedure burns the invocation reward, the Bonus procedure returns half the invocation reward to the invocator, and the GetAllStats function returns all call counters.\n\n### Flow Diagram\n\nThe flow diagram of the HM25Plus smart contract is as follows:\n\n1.  **Initialization**: The contract's state is initialized by setting all call counters to 0.\n2.  **Procedure Invocation**: The user invokes one of the procedures (Echo, Burn, or Bonus) or the GetAllStats function.\n3.  **Procedure Execution**: The invoked procedure executes and updates the contract's state accordingly.\n4.  **GetAllStats Function**: The GetAllStats function returns all call counters.\n\n### Accessed Data\n\nThe HM25Plus smart contract accesses the following data:\n\n*   **Invocation Reward**: The contract accesses the invocation reward to determine the amount to be transferred or burned.\n*   **Contract State**: The contract accesses its own state to update the call counters.\n\n### Processing Logic\n\nThe HM25Plus smart contract follows the following processing logic:\n\n1.  **Echo Procedure**: The Echo procedure increments the Echo call counter and transfers the full invocation reward to the invocator if available.\n2.  **Burn Procedure**: The Burn procedure increments the Burn call counter and burns the invocation reward if available.\n3.  **Bonus Procedure**: The Bonus procedure increments the Bonus call counter, transfers half the invocation reward to the invocator, and burns the remaining half if the reward is greater than 1.\n4.  **GetAllStats Function**: The GetAllStats function returns all call counters.\n\n### Parameter Control and Edge Cases\n\nThe HM25Plus smart contract handles the following parameter control and edge cases:\n\n*   **Reward Handling**: The contract handles the case where the reward is 1 in the Bonus procedure to avoid division by zero.\n*   **Procedure IDs**: The contract uses named constants for procedure IDs to improve code readability and maintainability.\n\n### Data Handling Rules\n\nThe HM25Plus smart contract follows the following data handling rules:\n\n| Field | Data Type | Description |\n| --- | --- | --- |\n| echoCallCount | uint64 | Number of Echo calls |\n| burnCallCount | uint64 | Number of Burn calls |\n| bonusCallCount | uint64 | Number of Bonus calls |\n\n**Initialization Rules**\n\n*   The contract's state is initialized by setting all call counters to 0.\n\n**Update Rules**\n\n*   The Echo procedure increments the Echo call counter.\n*   The Burn procedure increments the Burn call counter.\n*   The Bonus procedure increments the Bonus call counter.\n*   The GetAllStats function returns all call counters.\n\n**Validation Rules**\n\n*   The contract checks if the invocation reward is available before transferring or burning it.\n*   The contract checks if the reward is greater than 0 before transferring or burning it.\n*   The contract checks if the reward is greater than 1 before dividing it by 2 in the Bonus procedure.\n\n### Code Snippets\n\nThe following code snippets demonstrate the key functionality of the HM25Plus smart contract:\n\n// Echo procedure\nQPI_PROCEDURE(Echo)\n{\n    // Increment the Echo call counter\n    state.echoCallCount++;\n    // Check if there is an invocation reward\n    if (qpi.invocationReward() > 0)\n    {\n        // Transfer the full invocation reward to the invocator\n        QPI_TRANSFER(qpi.transfer(qpi.invocator(), qpi.invocationReward()));\n    }\n}\n\n// Burn procedure\nQPI_PROCEDURE(Burn)\n{\n    // Increment the Burn call counter\n    state.burnCallCount++;\n    // Check if there is an invocation reward\n    if (qpi.invocationReward() > 0)\n    {\n        // Burn the invocation reward\n        QPI_BURN(qpi.burn(qpi.invocationReward()));\n    }\n}\n\n// Bonus procedure\nQPI_PROCEDURE(Bonus)\n{\n    // Increment the Bonus call counter\n    state.bonusCallCount++;\n    // Get the invocation reward\n    uint64 reward = qpi.invocationReward();\n    // Check if the reward is greater than 0\n    if (reward > 0)\n    {\n        // Check if the reward is greater than 1 to avoid division by zero\n        if (reward > 1)\n        {\n            // Transfer half of the reward to the invocator\n            QPI_TRANSFER(qpi.transfer(qpi.invocator(), reward / 2));\n            // Burn the remaining half of the reward\n            QPI_BURN(qpi.burn(reward - (reward / 2)));\n        }\n        else\n        {\n            // If the reward is 1, burn it\n            QPI_BURN(qpi.burn(reward));\n        }\n    }\n}\n\n// GetAllStats function\nQPI_FUNCTION(GetAllStats)\n{\n    // Create an output object to store the call counters\n    GetAllStats_output output;\n    // Set the output fields to the current call counters\n    output.echoCallCount = state.echoCallCount;\n    output.burnCallCount = state.burnCallCount;\n    output.bonusCallCount = state.bonusCallCount;\n    // Return the output object\n    return output;\n}\n\n### Recommendations\n\n*   Consider using separate files for different contract components, such as procedures and functions, to improve maintainability and scalability.\n*   Use a consistent naming convention throughout the contract to improve readability.\n*   Extract helper functions to reduce code duplication and improve maintainability.\n*   Use named constants instead of magic numbers to improve code readability and maintainability.\n*   Add more comments to explain the purpose and behavior of each section of code.\n*   Use consistent indentation and line lengths throughout the contract to improve readability.",
  "audit_report": "**Smart Contract Audit Report: HM25Plus**\n\n**Introduction**\n\nThis audit report provides an analysis of the HM25Plus smart contract, which features four main functions: Echo, Burn, Bonus, and GetAllStats. The contract is written in C++ and utilizes the QPI namespace for smart contract development.\n\n**Security Vulnerabilities**\n\n1.  **Reentrancy Vulnerability**: The contract does not implement any reentrancy protection mechanisms. This makes it vulnerable to reentrancy attacks, where an attacker can repeatedly call the contract's functions, causing it to execute the same code multiple times and potentially leading to unintended behavior or financial losses.\n2.  **Unprotected Function Calls**: The contract's functions, such as Echo, Burn, and Bonus, do not have any protection against unauthorized function calls. This makes it possible for an attacker to call these functions without proper authorization, potentially leading to unintended behavior or financial losses.\n3.  **Lack of Access Control**: The contract does not implement any access control mechanisms, making it possible for anyone to call its functions and potentially leading to unintended behavior or financial losses.\n\n**Risky Patterns**\n\n1.  **Magic Numbers**: The contract uses magic numbers, such as 1 and 2, to represent procedure IDs. This makes the code harder to read and maintain, as the meaning of these numbers is not immediately clear.\n2.  **Duplicated Code**: The contract has duplicated code in the constructor and the `GetAllStats` function, which makes it harder to maintain and update.\n3.  **Complex Logic**: The contract's `Bonus` function has complex logic, which makes it harder to understand and maintain.\n\n**Optimization Suggestions**\n\n1.  **Use Separate Files**: Consider using separate files for different contract components, such as procedures and functions, to improve maintainability and scalability.\n2.  **Use Consistent Naming Conventions**: Use a consistent naming convention throughout the contract to improve readability.\n3.  **Extract Helper Functions**: Extract helper functions to reduce code duplication and improve maintainability.\n4.  **Use Named Constants**: Use named constants instead of magic numbers to improve code readability and maintainability.\n5.  **Add More Comments**: Add more comments to explain the purpose and behavior of each section of code.\n6.  **Use Consistent Indentation and Line Lengths**: Use consistent indentation and line lengths throughout the contract to improve readability.\n\n**Best Practices**\n\n1.  **Implement Reentrancy Protection**: Implement reentrancy protection mechanisms to prevent reentrancy attacks.\n2.  **Implement Access Control**: Implement access control mechanisms to prevent unauthorized function calls.\n3.  **Use Secure Function Calls**: Use secure function calls to prevent unauthorized function calls.\n4.  **Use Consistent Naming Conventions**: Use a consistent naming convention throughout the contract to improve readability.\n5.  **Extract Helper Functions**: Extract helper functions to reduce code duplication and improve maintainability.\n6.  **Use Named Constants**: Use named constants instead of magic numbers to improve code readability and maintainability.\n\n**Recommendations**\n\n1.  Implement reentrancy protection mechanisms to prevent reentrancy attacks.\n2.  Implement access control mechanisms to prevent unauthorized function calls.\n3.  Use secure function calls to prevent unauthorized function calls.\n4.  Use consistent naming conventions throughout the contract to improve readability.\n5.  Extract helper functions to reduce code duplication and improve maintainability.\n6.  Use named constants instead of magic numbers to improve code readability and maintainability.\n7.  Add more comments to explain the purpose and behavior of each section of code.\n8.  Use consistent indentation and line lengths throughout the contract to improve readability.",
  "test_plan": "**Test Plan for HM25Plus Smart Contract**\n\n**Introduction:**\nThe HM25Plus smart contract is a C++ contract that features four main functions: Echo, Burn, Bonus, and GetAllStats. This test plan aims to ensure that the contract behaves as expected and handles various input scenarios correctly.\n\n**Test Cases:**\n\n### Echo Procedure\n\n1. **Test Case 1: Echo with Invocation Reward**\n\t* Input: Invocation reward > 0\n\t* Expected Output: Full invocation reward transferred to the invocator\n\t* Validation Steps:\n\t\t+ Verify that the invocation reward is transferred to the invocator\n\t\t+ Check that the echoCallCount is incremented\n2. **Test Case 2: Echo without Invocation Reward**\n\t* Input: Invocation reward = 0\n\t* Expected Output: No invocation reward transferred\n\t* Validation Steps:\n\t\t+ Verify that no invocation reward is transferred\n\t\t+ Check that the echoCallCount is incremented\n\n### Burn Procedure\n\n1. **Test Case 3: Burn with Invocation Reward**\n\t* Input: Invocation reward > 0\n\t* Expected Output: Invocation reward burned\n\t* Validation Steps:\n\t\t+ Verify that the invocation reward is burned\n\t\t+ Check that the burnCallCount is incremented\n2. **Test Case 4: Burn without Invocation Reward**\n\t* Input: Invocation reward = 0\n\t* Expected Output: No invocation reward burned\n\t* Validation Steps:\n\t\t+ Verify that no invocation reward is burned\n\t\t+ Check that the burnCallCount is incremented\n\n### Bonus Procedure\n\n1. **Test Case 5: Bonus with Invocation Reward > 1**\n\t* Input: Invocation reward > 1\n\t* Expected Output: Half of the invocation reward transferred to the invocator, remaining half burned\n\t* Validation Steps:\n\t\t+ Verify that half of the invocation reward is transferred to the invocator\n\t\t+ Check that the remaining half is burned\n\t\t+ Check that the bonusCallCount is incremented\n2. **Test Case 6: Bonus with Invocation Reward = 1**\n\t* Input: Invocation reward = 1\n\t* Expected Output: Invocation reward burned\n\t* Validation Steps:\n\t\t+ Verify that the invocation reward is burned\n\t\t+ Check that the bonusCallCount is incremented\n3. **Test Case 7: Bonus without Invocation Reward**\n\t* Input: Invocation reward = 0\n\t* Expected Output: No invocation reward transferred or burned\n\t* Validation Steps:\n\t\t+ Verify that no invocation reward is transferred or burned\n\t\t+ Check that the bonusCallCount is incremented\n\n### GetAllStats Function\n\n1. **Test Case 8: GetAllStats**\n\t* Input: None\n\t* Expected Output: Current call counters for Echo, Burn, and Bonus procedures\n\t* Validation Steps:\n\t\t+ Verify that the output matches the current call counters\n\n**Edge Cases:**\n\n1. **Test Case 9: Invocation Reward = 0 for all procedures**\n\t* Input: Invocation reward = 0 for all procedures\n\t* Expected Output: No invocation reward transferred or burned\n\t* Validation Steps:\n\t\t+ Verify that no invocation reward is transferred or burned\n\t\t+ Check that the call counters are incremented correctly\n2. **Test Case 10: Large Invocation Reward**\n\t* Input: Large invocation reward (> 1000)\n\t* Expected Output: Invocation reward handled correctly\n\t* Validation Steps:\n\t\t+ Verify that the invocation reward is handled correctly\n\t\t+ Check that the call counters are incremented correctly\n\n**Failure Scenarios:**\n\n1. **Test Case 11: Invalid Invocation Reward**\n\t* Input: Invalid invocation reward (e.g., negative value)\n\t* Expected Output: Contract fails with an error\n\t* Validation Steps:\n\t\t+ Verify that the contract fails with an error\n2. **Test Case 12: Reentrancy Attack**\n\t* Input: Malicious input that attempts to reenter the contract\n\t* Expected Output: Contract fails with an error\n\t* Validation Steps:\n\t\t+ Verify that the contract fails with an error\n\n**Validation Steps:**\n\n1. Verify that the contract's state is updated correctly after each procedure call.\n2. Check that the invocation reward is handled correctly for each procedure.\n3. Verify that the call counters are incremented correctly for each procedure.\n4. Check that the contract fails with an error for invalid input scenarios.\n\n**Test Environment:**\n\n* QPI test framework\n* C++ compiler\n* Smart contract simulator\n\n**Test Schedule:**\n\n* Test cases will be executed in the following order:\n\t1. Echo procedure test cases\n\t2. Burn procedure test cases\n\t3. Bonus procedure test cases\n\t4. GetAllStats function test case\n\t5. Edge cases\n\t6. Failure scenarios\n* Each test case will be executed multiple times to ensure consistency and reliability.\n\n**Test Deliverables:**\n\n* Test plan document\n* Test cases and test data\n* Test execution report\n* Defect report (if any)\n\n**Test Completion Criteria:**\n\n* All test cases have been executed successfully.\n* All defects have been resolved and retested.\n* The contract's behavior matches the expected output for all test cases.",
  "qubic_logs": "--- STDOUT ---\nCompiling... OK\nRunning on VM... All tests passed.\n\n--- STDERR ---\n"
}